 <script>
        class MessengerClient {
            constructor(certAuthorityPublicKey, govPublicKey) {
                this.caPublicKey = certAuthorityPublicKey;
                this.govPublicKey = govPublicKey;
                this.conns = {};
                this.certs = {};
                this.EGKeyPair = null;
                this.username = null;
            }


            async generateCertificate(username) {
                this.EGKeyPair = await generateEG();
                this.username = username;
                const certificate = {
                    username: username,
                    publicKey: this.EGKeyPair.pub
                };
                return certificate;
            }


            async receiveCertificate(certificate, signature) {
                const certString = stringifyCert(certificate);
                const isValid = await verifyWithECDSA(this.caPublicKey, certString, signature);
                if (!isValid) {
                    throw new Error('Certificate signature verification failed - potential tampering detected');
                }
                this.certs[certificate.username] = certificate;
            }


            async deriveMessageKey(chainKey) {
                const messageKey = await HMACtoAESKey(chainKey, 'message');
                const nextChainKey = await HMACtoHMACKey(chainKey, 'chain');
                return { messageKey, nextChainKey };
            }


            async sendMessage(name, plaintext) {
                let conn = this.conns[name];
                if (!conn) {
                    conn = this.conns[name] = {};
                    conn.DHs = await generateEG();
                    conn.currentDHr = this.certs[name].publicKey;
                    const dhSecret = await computeDH(conn.DHs.sec, conn.currentDHr);
                    const [RK, CKs] = await HKDF(dhSecret, dhSecret, 'DoubleRatchet');
                    conn.RK = RK;
                    conn.CKs = CKs;
                    conn.currentCKr = null;
                    conn.Ns = 0;
                    conn.currentNr = 0;
                    conn.PNs = 0;
                    conn.currentSkipped = new Map();
                    conn.oldChains = new Map();
                }


                const { messageKey, nextChainKey } = await this.deriveMessageKey(conn.CKs);
                conn.CKs = nextChainKey;


                const receiverIV = genRandomSalt();
                const ivGov = genRandomSalt();
                const header = {
                    dhPublicKey: conn.DHs.pub,
                    Ns: conn.Ns,
                    PNs: conn.PNs,
                    receiverIV: receiverIV,
                    ivGov: ivGov
                };


                const messageKeyRaw = await subtle.exportKey('raw', messageKey);
                const govDH = await computeDH(conn.DHs.sec, this.govPublicKey);
                const govKey = await HMACtoAESKey(govDH, govEncryptionDataStr);
                const cGov = await encryptWithGCM(govKey, messageKeyRaw, ivGov);
                header.vGov = conn.DHs.pub;
                header.cGov = cGov;


                const ciphertext = await encryptWithGCM(
                    messageKey,
                    plaintext,
                    receiverIV,
                    JSON.stringify(header)
                );
                conn.Ns++;
                return [header, ciphertext];
            }


            async findMessageKey(chain, Ns) {
                if (chain.skipped.has(Ns)) {
                    const messageKey = chain.skipped.get(Ns);
                    chain.skipped.delete(Ns);
                    return messageKey;
                }
                if (Ns < chain.Nr) {
                    throw new Error(`Message replay or too old. Got Ns: ${Ns}, but expected Nr >= ${chain.Nr}`);
                }


                let messageKey;
                let currentCKr = chain.CKr;
                let currentNr = chain.Nr;


                if (Ns === currentNr) {
                    const { messageKey: derivedKey, nextChainKey } = await this.deriveMessageKey(currentCKr);
                    messageKey = derivedKey;
                    chain.CKr = nextChainKey;
                    chain.Nr++;
                    return messageKey;
                }


                while (currentNr < Ns) {
                    const { messageKey: skippedKey, nextChainKey } = await this.deriveMessageKey(currentCKr);
                    chain.skipped.set(currentNr, skippedKey);
                    currentCKr = nextChainKey;
                    currentNr++;
                }


                const { messageKey: derivedKey, nextChainKey } = await this.deriveMessageKey(currentCKr);
                messageKey = derivedKey;
                chain.CKr = nextChainKey;
                chain.Nr = currentNr + 1;
                return messageKey;
            }


            async receiveMessage(name, [header, ciphertext]) {
                let conn = this.conns[name];
                const headerKey = header.dhPublicKey;
                let chain;
                let isOldChain = false;


                if (!conn) {
                    conn = this.conns[name] = {};
                    const dhSecret = await computeDH(this.EGKeyPair.sec, headerKey);
                    const [RK, CKr] = await HKDF(dhSecret, dhSecret, 'DoubleRatchet');
                    conn.RK = RK;
                    conn.Ns = 0;
                    conn.PNs = 0;
                    conn.currentDHr = headerKey;
                    conn.currentCKr = CKr;
                    conn.currentNr = 0;
                    conn.currentSkipped = new Map();
                    conn.oldChains = new Map();
                    conn.DHs = await generateEG();
                    const dhSecretNext = await computeDH(conn.DHs.sec, conn.currentDHr);
                    const [RK_next, CKs] = await HKDF(conn.RK, dhSecretNext, 'DoubleRatchet');
                    conn.RK = RK_next;
                    conn.CKs = CKs;
                    chain = { CKr: conn.currentCKr, Nr: conn.currentNr, skipped: conn.currentSkipped };
                } else if (headerKey === conn.currentDHr) {
                    chain = { CKr: conn.currentCKr, Nr: conn.currentNr, skipped: conn.currentSkipped };
                } else if (conn.oldChains.has(headerKey)) {
                    chain = conn.oldChains.get(headerKey);
                    isOldChain = true;
                } else {
                    conn.oldChains.set(conn.currentDHr, { CKr: conn.currentCKr, Nr: conn.currentNr, skipped: conn.currentSkipped });
                    conn.PNs = conn.Ns;
                    conn.Ns = 0;
                    const dhSecret = await computeDH(conn.DHs.sec, headerKey);
                    const [RK, CKr] = await HKDF(conn.RK, dhSecret, 'DoubleRatchet');
                    conn.RK = RK;
                    conn.currentDHr = headerKey;
                    conn.currentCKr = CKr;
                    conn.currentNr = 0;
                    conn.currentSkipped = new Map();
                    conn.DHs = await generateEG();
                    const dhSecretNext = await computeDH(conn.DHs.sec, conn.currentDHr);
                    const [RK_next, CKs] = await HKDF(conn.RK, dhSecretNext, 'DoubleRatchet');
                    conn.RK = RK_next;
                    conn.CKs = CKs;
                    chain = { CKr: conn.currentCKr, Nr: conn.currentNr, skipped: conn.currentSkipped };
                }


                const messageKey = await this.findMessageKey(chain, header.Ns);
                if (!isOldChain) {
                    conn.currentCKr = chain.CKr;
                    conn.currentNr = chain.Nr;
                }


                try {
                    const plaintextBuffer = await decryptWithGCM(
                        messageKey,
                        ciphertext,
                        header.receiverIV,
                        JSON.stringify(header)
                    );
                    return bufferToString(plaintextBuffer);
                } catch (error) {
                    console.error('Decryption failed!', error);
                    throw new Error('Decryption failed: Possible tampering or key mismatch');
                }
            }
        }
    </script>
